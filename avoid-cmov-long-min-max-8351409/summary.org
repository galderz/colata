* 28.3.25
Added jmh code to resolve xctrace out of SDKROOT.
Created https://bugs.openjdk.org/browse/CODETOOLS-7903982 to improve that.

Tried to run benchmark with that but failed:
#+begin_src bash
TEST="micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax" MICRO="OPTIONS=-p probability=100 -jvmArgs -XX:-UseSuperWord -prof xctraceasm -v EXTRA;FORK=1" CONF=release BUILD_LOG=warn make test
pushd /Users/galder/1/jdk-avoid-cmov-long-min-max
CONF=release-darwin-arm64 make -s
popd
touch /Users/galder/1/jdk-avoid-cmov-long-min-max/build/release-darwin-arm64/jdk/bin/java
~/1/jdk-avoid-cmov-long-min-max ~/1/colata/avoid-cmov-long-min-max-8351409
Building target 'default (exploded-image)' in configuration 'release-darwin-arm64'
Finished building target 'default (exploded-image)' in configuration 'release-darwin-arm64'
~/1/colata/avoid-cmov-long-min-max-8351409
cd /Users/galder/1/jdk-avoid-cmov-long-min-max
CONF=release-darwin-arm64 make test
make[1]: Entering directory '/Users/galder/1/jdk-avoid-cmov-long-min-max'
Building target 'test' in configuration 'release-darwin-arm64'
Running tests using MICRO control variable 'OPTIONS=-p probability=100 -jvmArgs -XX:-UseSuperWord -prof xctraceasm -v EXTRA;FORK=1'
Test selection 'micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax', will run:
 micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax

Running test 'micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax'
Profilers failed to initialize, exiting.
"xctrace version" failed: [dyld[99580]: Library not loaded: @rpath/XCTraceCore.framework/Versions/A/XCTraceCore
  Referenced from: <05ABD51C-583F-305C-BAC6-95F050084452> /nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/Developer/usr/bin/xctrace
  Reason: tried: '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/SharedFrameworks/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file), '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file), '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Independence/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file), '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Frameworks/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file), '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/SharedFrameworks/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file), '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file), '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Independence/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file), '/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Frameworks/XCTraceCore.framework/Versions/A/XCTraceCore' (no such file)
]
Finished running test 'micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax'
Test report is stored in build/release-darwin-arm64/test-results/micro_org_openjdk_bench_java_lang_MinMaxVector_longReductionMultiplyMax

==============================
Test summary
==============================
   TEST                                              TOTAL  PASS  FAIL ERROR  SKIP   
   micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax
>>                                                       1     0     0     1     0 <<
==============================
TEST FAILURE

make[2]: *** [/Users/galder/1/jdk-avoid-cmov-long-min-max/make/Init.gmk:150: main] Error 1
make[1]: *** [/Users/galder/1/jdk-avoid-cmov-long-min-max/make/PreInit.gmk:159: test] Error 2
make[1]: Leaving directory '/Users/galder/1/jdk-avoid-cmov-long-min-max'
make: *** [../nix-make/OpenJDK.gmk:103: test] Error 2
#+end_src
The issue is that XCTraceCore is not in the devkit.
Created https://bugs.openjdk.org/browse/JDK-8353177

Added XCTraceCore to the devkit and tried again,
but something else is missing, ~InstrumentsTrace~:
#+begin_src bash
[nix-shell:~/1/colata/avoid-cmov-long-min-max-8351409]$ TEST="micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax" MICRO="OPTIONS=-p probability=100 -jvmArgs -XX:-UseSuperWord -prof xctraceasm -v EXTRA;FORK=1" CONF=release BUILD_LOG=warn make test
pushd /Users/galder/1/jdk-avoid-cmov-long-min-max
CONF=release-darwin-arm64 make -s
popd
touch /Users/galder/1/jdk-avoid-cmov-long-min-max/build/release-darwin-arm64/jdk/bin/java
~/1/jdk-avoid-cmov-long-min-max ~/1/colata/avoid-cmov-long-min-max-8351409
Building target 'default (exploded-image)' in configuration 'release-darwin-arm64'
Finished building target 'default (exploded-image)' in configuration 'release-darwin-arm64'
~/1/colata/avoid-cmov-long-min-max-8351409
cd /Users/galder/1/jdk-avoid-cmov-long-min-max
CONF=release-darwin-arm64 make test
make[1]: Entering directory '/Users/galder/1/jdk-avoid-cmov-long-min-max'
Building target 'test' in configuration 'release-darwin-arm64'
Running tests using MICRO control variable 'OPTIONS=-p probability=100 -jvmArgs -XX:-UseSuperWord -prof xctraceasm -v EXTRA;FORK=1'
Test selection 'micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax', will run:
 micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax

Running test 'micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax'
Profilers failed to initialize, exiting.
"xctrace version" failed: [dyld[24506]: Library not loaded: @rpath/InstrumentsTrace.framework/Versions/A/InstrumentsTrace
  Referenced from: <EC019860-6E8F-343C-82AA-B9F9374E9129> /nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/XCTraceCore.framework/Versions/A/XCTraceCore
  Reason: tried: '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/XCTraceCore.framework/Versions/A/../../../InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/XCTraceCore.framework/Versions/A/../../../../../../../SharedFrameworks/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/XCTraceCore.framework/Versions/A/../../../../Independence/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/SharedFrameworks/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Independence/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Frameworks/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/SharedFrameworks/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Applications/Instruments.app/Contents/Frameworks/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Independence/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file), '/nix/store/fqdg3ybx87d3kpg2gqqxl5h4xlwj4wrq-Xcode16.2-MacOSX15/Xcode/Contents/Developer/Frameworks/InstrumentsTrace.framework/Versions/A/InstrumentsTrace' (no such file)
]
Finished running test 'micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax'
Test report is stored in build/release-darwin-arm64/test-results/micro_org_openjdk_bench_java_lang_MinMaxVector_longReductionMultiplyMax

==============================
Test summary
==============================
   TEST                                              TOTAL  PASS  FAIL ERROR  SKIP   
   micro:org.openjdk.bench.java.lang.MinMaxVector.longReductionMultiplyMax
>>                                                       1     0     0     1     0 <<
==============================
TEST FAILURE

make[2]: *** [/Users/galder/1/jdk-avoid-cmov-long-min-max/make/Init.gmk:150: main] Error 1
make[1]: *** [/Users/galder/1/jdk-avoid-cmov-long-min-max/make/PreInit.gmk:159: test] Error 2
make[1]: Leaving directory '/Users/galder/1/jdk-avoid-cmov-long-min-max'
make: *** [../nix-make/OpenJDK.gmk:104: test] Error 2
#+end_src
* 27.3.25
To breakpoint to .ad being called,
try putting breakpoint in MatchOper::reg
#+begin_src bash
MachOper::reg(PhaseRegAlloc *, const Node *) const machnode.cpp:39
maxL_reg_regNode::emit(C2_MacroAssembler *, PhaseRegAlloc *) const aarch64.ad:15683
PhaseOutput::scratch_emit_size(const Node *) output.cpp:3385
MachNode::emit_size(PhaseRegAlloc *) const machnode.cpp:157
MachNode::size(PhaseRegAlloc *) const machnode.cpp:149
PhaseOutput::shorten_branches(unsigned int *) output.cpp:539
PhaseOutput::Output() output.cpp:339
Compile::Code_Gen() compile.cpp:3081
Compile::Compile(ciEnv *, ciMethod *, int, Options, DirectiveSet *) compile.cpp:891
Compile::Compile(ciEnv *, ciMethod *, int, Options, DirectiveSet *) compile.cpp:693
C2Compiler::compile_method(ciEnv *, ciMethod *, int, bool, DirectiveSet *) c2compiler.cpp:141
CompileBroker::invoke_compiler_on_method(CompileTask *) compileBroker.cpp:2331
CompileBroker::compiler_thread_loop() compileBroker.cpp:1975
CompilerThread::thread_entry(JavaThread *, JavaThread *) compilerThread.cpp:67
JavaThread::thread_main_inner() javaThread.cpp:776
JavaThread::run() javaThread.cpp:761
Thread::call_run() thread.cpp:231
thread_native_entry(Thread *) os_bsd.cpp:601
#+end_src
* 25.3.25
todo: run without intrinsic
** benchmarking aarch64
*** branch never taken (option 3)
#+begin_src bash
Benchmark                            (probability)  (size)   Mode  Cnt     Score    Error   Units
MinMaxVector.longReductionSimpleMax            100    2048  thrpt    8  3810.543 ? 98.505  ops/ms
#+end_src
*** branch always taken (option 2)
#+begin_src bash
Benchmark                            (probability)  (size)   Mode  Cnt     Score    Error   Units
MinMaxVector.longReductionSimpleMax            100    2048  thrpt    8  1757.789 ? 39.362  ops/ms
#+end_src
*** cmov (option 1)
#+begin_src bash
Benchmark                            (probability)  (size)   Mode  Cnt     Score    Error   Units
MinMaxVector.longReductionSimpleMax            100    2048  thrpt    8  1095.610 ? 13.587  ops/ms
#+end_src
** source date error
Attempt to run benchmark but had issues building test:

#+begin_src bash
/nix/store/5y040sypyg0amh0igxs9rnx5fmj0d88i-temurin-bin-23.0.2/bin/jar --create --date 1980-01-01T00:00:00Z --file /Users/galder/1/jdk-avoid-cmov-long-min-max/build/release-darwin-arm64/support/modules_libs/java.base/jrt-fs.jar --manifest /Users/galder/1/jdk-avoid-cmov-long-min-max/build/release-darwin-arm64/support/modules_libs/java.base/_the.jrt-fs.jar_manifest 
...
date 1980-01-01T00:00:00Z is not within the valid range 1980-01-01T00:00:02Z to 2099-12-31T23:59:59Z
#+end_src

#+begin_src bash
bash configure \
   --disable-precompiled-headers \
   --with-boot-jdk=/nix/store/5y040sypyg0amh0igxs9rnx5fmj0d88i-temurin-bin-23.0.2 \
   --with-conf-name=release-darwin-arm64 \
   --with-jmh=build/jmh/jars \
   --with-devkit=/nix/store/vhsix1jn849mpxggwbw2zh1nbxpy0grc-Xcode16.2-MacOSX15 \
   --enable-hsdis-bundling --with-capstone=/nix/store/g9xz7lq27dsdvrg0i666nwc6322af9p1-capstone-5.0.5 --with-hsdis=capstone
...
checking what hotspot build time to use... 1980-01-01T00:00:00Z (from --with-source-date)
#+end_src

Nix:
#+begin_src bash
checking what source date to use... 315532800, from SOURCE_DATE_EPOCH
#+end_src

Leo:
#+begin_src bash
checking what source date to use... 1742909454, from 'current' (default)
#+end_src

Issue is that nix-shell sets ~SOURCE_DATE_EPOCH~:
#+begin_src bash
$ echo $SOURCE_DATE_EPOCH
315532800
#+end_src

Several ways to fix it.
Either pass in a source date, or unset ~SOURCE_DATE_EPOCH~ env variable:
https://espg.github.io/linux/nix.html

Cause: https://github.com/openjdk/jdk/pull/
** other way, branch always taken
#+begin_src asm
instruct maxL_reg_reg(iRegLNoSp dst, iRegL src1, iRegL src2)
%{
  match(Set dst (MaxL src1 src2));
  ins_cost(INSN_COST * 3);

  ins_encode %{
    Label done;
    __ mov(as_Register($dst$$reg), as_Register($src1$$reg));
    __ cmp(as_Register($src1$$reg), as_Register($src2$$reg));
    __ br(Assembler::GE, done);
    __ mov(as_Register($dst$$reg), as_Register($src2$$reg));
    __ bind(done);
  %}
  ins_pipe(pipe_cmp_branch);
%}
#+end_src

#+begin_src asm
  0x00000001382cfd68:   mov		x13, #0xb
  0x00000001382cfd7c:   mul		x14, x14, x13
  ...
  0x00000001382cfdb8:   mov		x0, x14             ; x0 (dst) <- x14 (src1, value)
  0x00000001382cfdbc:   cmp		x14, x12            ; x14 (src1, value) >= x12 (src2, max)
  0x00000001382cfdc0:   b.ge		#0x1382cfdc8        ; yes, it's always greater so branch taken
  0x00000001382cfdc4:   mov		x0, x12             ;*invokestatic max {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - Test::test@25 (line 24)
  0x00000001382cfdc8:   cmp		w11, #0x3fd
#+end_src
** one way v2, branch never taken
#+begin_src asm
instruct maxL_reg_reg(iRegLNoSp dst, iRegL src1, iRegL src2)
%{
  match(Set dst (MaxL src1 src2));
  ins_cost(INSN_COST * 3);

  ins_encode %{
    Label done;
    __ mov(as_Register($dst$$reg), as_Register($src2$$reg));
    __ cmp(as_Register($src2$$reg), as_Register($src1$$reg));
    __ br(Assembler::LT, done);
    __ mov(as_Register($dst$$reg), as_Register($src1$$reg));
    __ bind(done);
  %}
  ins_pipe(pipe_cmp_branch);
%}
#+end_src
#+begin_src asm
  0x00000001282cfd98:   mul		x12, x12, x13
  ...
  0x00000001282cfdb8:   mov		x0, x12             ; x0 (dst) <- x12 (value)
  0x00000001282cfdbc:   cmp		x12, x14            ; x12 (value), x14 (max)
  0x00000001282cfdc0:   b.lt		#0x1282cfdc8        ; value < max ? never taken branch
  0x00000001282cfdc4:   mov		x0, x14             ;*invokestatic max {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - Test::test@25 (line 24)
                                                            ; dst (dst) <- x14 max
#+end_src
** one way
Is this right?
#+begin_src asm
instruct maxL_reg_reg(iRegLNoSp dst, iRegL src1, iRegL src2)
%{
  match(Set dst (MaxL src1 src2));
  ins_cost(INSN_COST * 3);

  ins_encode %{
    Label done;
    __ mov(as_Register($dst$$reg), as_Register($src2$$reg));
    __ cmp(as_Register($dst$$reg), as_Register($src1$$reg));
    __ br(Assembler::LT, done);
    __ mov(as_Register($dst$$reg), as_Register($src1$$reg));
    __ bind(done);
  %}
  ins_pipe(pipe_cmp_branch);
%}
#+end_src
#+begin_src asm
  0x0000000137acfd68:   mov		x13, #0xb           ; x13 = 11
  ...
  0x0000000137acfd98:   mul		x12, x12, x13       ; value = 11 * data[i]
  ...
  0x0000000137acfdb8:   mov		x0, x12             ; mov dst <- src2 (value)
  0x0000000137acfdbc:   cmp		x0, x14             ; cmp dst (value), src1 (max)
  0x0000000137acfdc0:   b.lt		#0x137acfdc8        ; branch if (dst (value) < src1 (max)) ; branch won't happen because value always > max
  0x0000000137acfdc4:   mov		x0, x14             ;*invokestatic max {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - Test::test@25 (line 24)
                                                            ; mov dst <- src1 (max)
#+end_src
* 21.3.25
** branch one way
#+begin_src asm
instruct maxL_reg_reg(iRegLNoSp dst, iRegL src1, iRegL src2)
%{
  match(Set dst (MaxL src1 src2));
  ins_cost(INSN_COST * 3);

  ins_encode %{
    Label done;
    __ mov(as_Register($dst$$reg), as_Register($src2$$reg));
    __ cmp(as_Register($dst$$reg), as_Register($src1$$reg));
    __ br(Assembler::LT, done);
    __ mov(as_Register($dst$$reg), as_Register($src1$$reg));
    __ bind(done);
  %}
  ins_pipe(pipe_cmp_branch);
%}
#+end_src
** how to write branch code in backend
Create MyMax that does things manually.

Bytecode:
#+begin_src java
  static long test(long[]);
    descriptor: ([J)J
    flags: (0x0008) ACC_STATIC
    Code:
      stack=4, locals=8, args_size=1
         0: ldc2_w        #11                 // long -9223372036854775808l
         3: lstore_1
         4: iconst_0
         5: istore_3
         6: iload_3
         7: sipush        1024
        10: if_icmpge     46
        13: ldc2_w        #13                 // long 11l
        16: aload_0
        17: iload_3
        18: laload
        19: lmul
        20: lstore        4
        22: lload_1
        23: lload         4
        25: lcmp
        26: iflt          33
#+end_src

#+begin_src asm
 ;; 0x8000000000000000
 ;; 0xB
  0x000000012facfdd4:   mov		x12, #0xb
  0x000000012facfdd8:   mul		x11, x11, x12       ;*lmul {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - MyMax::test@19 (line 23)
                                                            ; x11 is value
  0x000000012facfddc:   mov		x8, #-0x8000000000000000
  0x000000012facfde0:   cmp		x11, x8             ; x8 is max
  0x000000012facfde4:   b.le		#0x12facff78        ;*iflt {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - MyMax::test@26 (line 24) 
 ;; B5: #	out( B28 B6 ) <- in( B4 )  Freq: 0.999996
 ;; 0x1
  0x000000012facfde8:   mov		w2, #1
  0x000000012facfdec:   cmp		w10, #1
  ...
 ;; B29: #	out( B25 ) <- in( B4 )  Freq: 4.76836e-07
 ;; 0x8000000000000000
  0x000000012facff78:   mov		x14, #-0x8000000000000000
  0x000000012facff7c:   mov			w2, wzr
  0x000000012facff80:   mov		x0, x11
  0x000000012facff84:   b		#0x12facff04        ;*iflt {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - MyMax::test@26 (line 24)
#+end_src
** disable macro expansion and implement cmov in backend
Trying to add backend implementation for MinL/MaxL.
Used code in here as base to decide how to approach it:
https://github.com/openjdk/jdk/compare/master...galderz:jdk:topic.intrinsify-max-min-long.0528?expand=1
Removed macro expansion for the nodes.

Java code:
#+begin_src java
     1	import java.util.Arrays;
     2
     3	public class Test
     4	{
     5	    static final int RANGE = 1024;
     6	    static final int ITER = 10_000;
     7
     8	    // Initializes data with increasing values,
     9	    // so max one of the branches is the one that is always taken
    10	    static void init(long[] data)
    11	    {
    12	        for (int i = 0; i < RANGE; i++)
    13	        {
    14	            data[i] = i + 1;
    15	        }
    16	    }
    17
    18	    static long test(long[] data)
    19	    {
    20	        long max = Long.MIN_VALUE;
    21	        for (int i = 0; i < RANGE; i++)
    22	        {
    23	            final long value = 11 * data[i];
    24	            final long tmp = Math.max(max, value);
    25	            max = tmp;
    26	        }
    27	        return max;
    28	    }
    29
    30	    public static void main(String[] args)
    31	    {
    32	        long[] data = new long[RANGE];
    33	        init(data);
    34
    35	        long result = 0;
    36	        for (long i = 0; i < ITER; i++)
    37	        {
    38	            result = test(data);
    39	        }
    40
    41	        // Validate
    42	        if (result == 11 * Arrays.stream(data).max().getAsLong())
    43	        {
    44	            System.out.println("Success");
    45	        }
    46	        else
    47	        {
    48	            throw new AssertionError("Failed");
    49	        }
    50	    }
    51	}
#+end_src

Before, ideal graph:
#+begin_src bash
 467  CMoveL  === _ 466 430 415  [[ 469 471 ]]  #long !orig=[414],[360],[132],377 !jvms: Test::test @ bci:25 (line 24)
 469  CmpL  === _ 467 413  [[ 470 ]]
 470  Bool  === _ 469  [[ 471 ]] [lt]
#+end_src

Before, assemly:
#+begin_src asm
  0x0000000110607dfc:   csel		x0, x10, x0, lt     ;*invokestatic max {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - Test::test@25 (line 24)
#+end_src

After, ideal graph:
#+begin_src bash
 412  MaxL  === _ 414 413  [[ 360 ]]  !orig=132,377 !jvms: Test::test @ bci:25 (line 24)
#+end_src

After, assembly:
#+begin_src asm
  0x000000010e6d3db0:   csel		x0, x14, x12, gt    ;*invokestatic max {reexecute=0 rethrow=0 return_oop=0}
                                                            ; - Test::test@25 (line 24)
#+end_src
